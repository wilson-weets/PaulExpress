var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from "react";
import { useFormik, getIn } from "formik";
import chunk from "lodash/chunk";
import { Grid, Row, Col } from "react-flexbox-grid";
import * as Yup from "yup";
import "@blueprintjs/datetime/lib/css/blueprint-datetime.css";
import { FormGroup, InputGroup, Intent, Classes } from "@blueprintjs/core";
import styled from "@emotion/styled";
import { FGDateInput } from "./controls/FGDateInput";
export function FormGenerator(props) {
    var groups = props.groups, initialValues = props.initialValues, onSubmit = props.onSubmit, inline = props.inline, fill = props.fill, validationSchema = props.validationSchema, showColons = props.showColons, _a = props.minLabelWidth, minLabelWidth = _a === void 0 ? 150 : _a, _b = props.labelAlignment, labelAlignment = _b === void 0 ? "left" : _b, _c = props.formatDate, formatDate = _c === void 0 ? "L" : _c;
    var finalValidationSchema = React.useMemo(function () {
        if (validationSchema)
            return validationSchema;
        var fields = groups
            .flatMap(function (g) { return g.fields; })
            .filter(function (f) { return !!f.validate && !!f.name; });
        var schemaObject = fields.reduce(function (prev, curr) {
            var _a;
            return (__assign(__assign({}, prev), (_a = {}, _a[curr.name] = curr.validate, _a)));
        }, {});
        return Yup.object().shape(schemaObject);
    }, [groups, validationSchema]);
    var formik = useFormik({
        initialValues: initialValues,
        onSubmit: onSubmit,
        validationSchema: finalValidationSchema
    });
    var getControlType = React.useCallback(function (field, intent) {
        if (intent === void 0) { intent = Intent.NONE; }
        var component = null;
        switch (field.type) {
            case "text": {
                return (React.createElement(InputGroup, { name: field.name, intent: intent, onChange: formik.handleChange, onBlur: formik.handleBlur, value: formik.values[field.name], placeholder: field.placeholder, fill: fill }));
            }
            case "date": {
                return (React.createElement(FGDateInput, { field: field, formik: formik, formatDate: formatDate, intent: intent, fill: fill }));
            }
        }
        return component;
    }, [fill, formatDate, formik]);
    var renderField = React.useCallback(function (field) {
        var disabled = field.disabled, style = field.style, labelInfo = field.labelInfo, label = field.label, name = field.name, requiredMark = field.requiredMark;
        var finalLabel = (React.createElement(React.Fragment, null,
            label,
            requiredMark && React.createElement("span", { className: Classes.TEXT_MUTED }, "\u00A0*"),
            showColons && React.createElement("span", null, "\u00A0:")));
        var formGroupProps = {
            disabled: disabled,
            style: style,
            labelInfo: labelInfo,
            label: finalLabel,
            inline: inline
        };
        var error = getIn(formik.errors, name);
        var intent = error ? Intent.DANGER : Intent.NONE;
        var helperText = error || "";
        return (React.createElement(FormGroup, __assign({}, formGroupProps, { intent: intent, helperText: helperText }), getControlType(field, intent)));
    }, [formik.errors, getControlType, inline, showColons]);
    var renderGroup = React.useCallback(function (g) {
        var itemsChunks = chunk(g.fields, g.columns);
        return itemsChunks.map(function (it, rowIndex) { return (React.createElement(Row, { key: rowIndex }, it.map(function (v, colIndex) { return (React.createElement(Col, { key: colIndex, xs: 12 / g.columns }, renderField(v))); }))); });
    }, [renderField]);
    var StyledForm = React.useMemo(function () {
        return styled.form(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n        & .", " {\n          flex: ", ";\n        }\n\n        & .", " {\n          min-width: ", ";\n          text-align: ", ";\n        }\n      "], ["\n        & .", " {\n          flex: ", ";\n        }\n\n        & .", " {\n          min-width: ", ";\n          text-align: ", ";\n        }\n      "])), Classes.FORM_CONTENT, fill ? 1 : "none", Classes.LABEL, minLabelWidth + "px", labelAlignment);
    }, [fill, labelAlignment, minLabelWidth]);
    React.useEffect(function () {
        console.log("VALUES", formik);
    }, [formik]);
    return (React.createElement(StyledForm, { onSubmit: formik.handleSubmit },
        React.createElement(Grid, { fluid: true }, groups.map(renderGroup))));
}
var templateObject_1;
