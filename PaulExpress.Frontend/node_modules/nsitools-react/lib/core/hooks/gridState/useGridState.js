var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import * as React from "react";
import * as lodash from "lodash";
export var useGridState = function (options) {
    var _a = __read(React.useState(__assign({
        data: [],
        columns: [],
        page: [],
        pageNumber: 1,
        nbPages: 1,
        totalCount: 0,
        pageSize: 10,
        serverMode: false,
        availablePageSizes: [10, 25, 50],
        sortKeys: {},
        enableMultiSort: false,
        globalFilter: "",
        enableFilter: true,
        enablePagination: true
    }, options)), 2), gridState = _a[0], setGridState = _a[1];
    var serverMode = gridState.serverMode, data = gridState.data, pageNumber = gridState.pageNumber, pageSize = gridState.pageSize, pagesSizes = gridState.availablePageSizes, totalCount = gridState.totalCount, page = gridState.page, columns = gridState.columns, enableMultiSort = gridState.enableMultiSort, sortKeys = gridState.sortKeys, globalFilter = gridState.globalFilter, enableFilter = gridState.enableFilter, enablePagination = gridState.enablePagination;
    var filterCache = React.useMemo(function () {
        return data.map(function (obj) {
            var objectKeys = Object.keys(obj);
            return {
                filterText: objectKeys.map(function (k) { return (obj[k] + "").toUpperCase(); }).join(""),
                item: obj
            };
        });
    }, [data]);
    // Compute basic total count and page data
    React.useEffect(function () {
        if (!serverMode) {
            setGridState(function (s) { return (__assign(__assign({}, s), { totalCount: data.length })); });
        }
        else {
            setGridState(function (s) { return (__assign(__assign({}, s), { page: data })); });
        }
    }, [data, serverMode, setGridState]);
    // COMPUTE SORT and FILTER
    var sortedData = React.useMemo(function () {
        if (!serverMode) {
            var filtered = globalFilter
                ? filterCache.filter(function (d) { return d.filterText.includes(globalFilter.toUpperCase()); }).map(function (d) { return d.item; })
                : data;
            var sortKeyFields = Object.keys(sortKeys).filter(function (d) { return sortKeys[d] !== "NONE"; });
            var sortKeyOrderBy = sortKeyFields
                .map(function (d) { return sortKeys[d]; })
                .filter(function (s) { return s !== "NONE"; })
                .map(function (s) { return (s === "ASC" ? "asc" : "desc"); });
            var sortedDataResults = lodash.orderBy(filtered, sortKeyFields, sortKeyOrderBy);
            return sortedDataResults;
        }
        else {
            return data;
        }
    }, [filterCache, serverMode, sortKeys, data, globalFilter]);
    // COMPUTE PAGE CONTENT AND PAGE COUNT
    React.useEffect(function () {
        if (!serverMode) {
            if (enablePagination) {
                var nextnbPages_1 = Math.ceil(totalCount / pageSize);
                var startIndex = (pageNumber - 1) * pageSize;
                var endIndex = startIndex + pageSize;
                var nextpage_1 = sortedData.slice(startIndex, endIndex);
                setGridState(function (s) { return (__assign(__assign({}, s), { page: nextpage_1, nbPages: nextnbPages_1, pageNumber: nextnbPages_1 < s.pageNumber && nextnbPages_1 > 0 ? nextnbPages_1 : s.pageNumber })); });
            }
            else {
                // Set only 1 page with the size of TotalCount
                setGridState(function (s) { return (__assign(__assign({}, s), { page: sortedData, nbPages: 1 })); });
            }
        }
        else {
            setGridState(function (s) { return (__assign(__assign({}, s), { page: sortedData })); });
        }
    }, [serverMode, sortedData, pageNumber, pageSize, totalCount, setGridState, enablePagination]);
    var nbPages = React.useMemo(function () { return Math.ceil(totalCount / pageSize); }, [pageSize, totalCount]);
    var canGoNextPage = React.useMemo(function () { return pageNumber < nbPages; }, [pageNumber, nbPages]);
    var canGoPreviousPage = React.useMemo(function () { return pageNumber > 1; }, [pageNumber]);
    var goToNextPage = React.useCallback(function () {
        if (canGoNextPage) {
            setGridState(function (s) { return (__assign(__assign({}, s), { pageNumber: s.pageNumber + 1 })); });
        }
    }, [canGoNextPage, setGridState]);
    var goToPreviousPage = React.useCallback(function () {
        if (canGoPreviousPage) {
            setGridState(function (s) { return (__assign(__assign({}, s), { pageNumber: s.pageNumber - 1 })); });
        }
    }, [canGoPreviousPage, setGridState]);
    var goToPage = React.useCallback(function (pgIndex) {
        if (pgIndex > 0 && pgIndex <= nbPages) {
            setGridState(function (s) { return (__assign(__assign({}, s), { pageNumber: pgIndex })); });
        }
    }, [nbPages, setGridState]);
    var setData = React.useCallback(function (nextData, dataOptions) {
        setGridState(function (s) {
            var nextState = __assign({}, s);
            nextState.data = nextData;
            if (dataOptions) {
                nextState.totalCount = dataOptions.totalCount;
            }
            return nextState;
        });
    }, [setGridState]);
    var _b = __read(React.useMemo(function () { return [pageSize, pageSize * (pageNumber - 1)]; }, [pageNumber, pageSize]), 2), take = _b[0], skip = _b[1];
    var toggleSort = React.useCallback(function (fieldName, sortOrder) {
        if (!fieldName)
            return;
        var currentKeySort = sortKeys[fieldName] || "NONE";
        var nextSortKeys = __assign({}, sortKeys);
        var nextSort = "NONE";
        if (sortOrder !== undefined) {
            nextSort = sortOrder;
        }
        else {
            if (currentKeySort === "NONE") {
                nextSort = "ASC";
            }
            else if (currentKeySort === "ASC") {
                nextSort = "DESC";
            }
        }
        if (!enableMultiSort) {
            // Reset other keys
            Object.keys(sortKeys).forEach(function (k) { return (nextSortKeys[k] = "NONE"); });
        }
        nextSortKeys[fieldName] = nextSort;
        setGridState(function (s) { return (__assign(__assign({}, s), { sortKeys: nextSortKeys })); });
    }, [enableMultiSort, setGridState, sortKeys]);
    var setPageSize = React.useCallback(function (size) {
        setGridState(function (s) { return (__assign(__assign({}, s), { pageSize: size })); });
    }, [setGridState]);
    var setGlobalFilter = React.useCallback(function (filter) {
        setGridState(function (s) { return (__assign(__assign({}, s), { globalFilter: filter, pageNumber: 1 })); });
    }, [setGridState]);
    var computedColumns = React.useMemo(function () {
        return columns.map(function (c) {
            var sortInfo = "NONE";
            if (c) {
                sortInfo = sortKeys[c] || "NONE";
            }
            return {
                fieldName: c,
                sortInfo: sortInfo,
                toggleSort: function () {
                    toggleSort(c);
                }
            };
        });
    }, [columns, sortKeys, toggleSort]);
    var pageNumbers = React.useMemo(function () {
        return nbPages
            ? Array(nbPages)
                .fill(null)
                .map(function (_, i) { return i + 1; })
            : [];
    }, [nbPages]);
    var sortKeysStrings = React.useMemo(function () {
        return Object.keys(sortKeys)
            .filter(function (k) { return sortKeys[k] !== "NONE"; })
            .map(function (k) { return "" + k + (sortKeys[k] === "DESC" ? "|d" : ""); });
    }, [sortKeys]);
    var setColumns = React.useCallback(function (c) {
        setGridState(function (s) { return (__assign(__assign({}, s), { columns: c })); });
    }, []);
    return {
        data: data,
        page: page,
        pageNumber: pageNumber,
        pageSize: pageSize,
        availablePageSizes: pagesSizes,
        nbPages: nbPages,
        totalCount: totalCount,
        sortKeys: sortKeys,
        sortKeysStrings: sortKeysStrings,
        columns: computedColumns,
        canGoNextPage: canGoNextPage,
        canGoPreviousPage: canGoPreviousPage,
        goToNextPage: goToNextPage,
        goToPreviousPage: goToPreviousPage,
        setPageSize: setPageSize,
        setGlobalFilter: setGlobalFilter,
        setColumns: setColumns,
        goToPage: goToPage,
        setData: setData,
        toggleSort: toggleSort,
        take: take,
        skip: skip,
        pageNumbers: pageNumbers,
        globalFilter: globalFilter,
        enableFilter: enableFilter,
        enablePagination: enablePagination
    };
};
