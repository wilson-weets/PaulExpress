var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
import * as React from "react";
import { Suggest } from "@blueprintjs/select";
import { MenuItem, Button, Position, Classes, Icon } from "@blueprintjs/core";
import styled from "styled-components";
import { IconNames } from "@blueprintjs/icons";
var SelectComp = Suggest.ofType();
var filterItem = function (query, item, _, exactMatch) {
    var normalizedTitle = item.displayValue.toLowerCase();
    var normalizedQuery = query.toLowerCase();
    if (exactMatch) {
        return normalizedTitle === normalizedQuery;
    }
    else {
        return normalizedTitle.indexOf(normalizedQuery) >= 0;
    }
};
var renderItem = function (item, _a) {
    var handleClick = _a.handleClick, modifiers = _a.modifiers, query = _a.query;
    if (!modifiers.matchesPredicate) {
        return null;
    }
    return (React.createElement(MenuItem, { active: modifiers.active, key: item.idValue, text: highlightText(item.displayValue, query), onClick: handleClick }));
};
var MyButton = styled(Button)(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  min-width: ", ";\n"], ["\n  min-width: ", ";\n"])), function (props) { return props.minwidth + "px"; });
var Container = styled.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  & .", " {\n    min-width: ", ";\n  }\n"], ["\n  & .", " {\n    min-width: ", ";\n  }\n"])), Classes.POPOVER_CONTENT, function (props) { return props.minwidth + "px"; });
export var SelectItemSearch = function (props) {
    // const selectedItem = props.listValues!.find(d => d.idValue === props.value);
    var _a = props.minWidth, minWidth = _a === void 0 ? 0 : _a;
    return (React.createElement(Container, { minwidth: minWidth },
        React.createElement(SelectComp, { items: props.listValues, closeOnSelect: false, itemPredicate: filterItem, itemRenderer: renderItem, popoverProps: {
                minimal: true,
                position: Position.BOTTOM_RIGHT,
                usePortal: false
            }, onItemSelect: function (i) {
                props.onValueChange(i.idValue);
            }, inputValueRenderer: function (i) { return i.displayValue; }, inputProps: {
                style: { minWidth: minWidth + "px" },
                rightElement: React.createElement(Icon, { icon: IconNames.CARET_DOWN, iconSize: 30 })
            } })));
};
function escapeRegExpChars(text) {
    return text.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}
function highlightText(text, query) {
    var lastIndex = 0;
    var words = query
        .split(/\s+/)
        .filter(function (word) { return word.length > 0; })
        .map(escapeRegExpChars);
    if (words.length === 0) {
        return [text];
    }
    var regexp = new RegExp(words.join("|"), "gi");
    var tokens = [];
    while (true) {
        var match = regexp.exec(text);
        if (!match) {
            break;
        }
        var length_1 = match[0].length;
        var before = text.slice(lastIndex, regexp.lastIndex - length_1);
        if (before.length > 0) {
            tokens.push(before);
        }
        lastIndex = regexp.lastIndex;
        tokens.push(React.createElement("span", { style: { color: "red" }, key: lastIndex }, match[0]));
    }
    var rest = text.slice(lastIndex);
    if (rest.length > 0) {
        tokens.push(rest);
    }
    return tokens;
}
var templateObject_1, templateObject_2;
